# Basic Example — @goodie

A minimal project demonstrating the full `@goodie` compile-time DI pipeline, including generic type wiring (`Repository<T>`).

## What this shows

- **`@Module()` + `@Provides()`** — factory methods for generic beans
- **Generic token resolution** — `Repository<User>` and `Repository<Order>` become separate `InjectionToken`s
- **`@Singleton()` services** — constructor injection of generic dependencies
- **Primitive providers** — `appName(): string` provided via `@Provides`

## Project structure

```
src/
  model.ts             # Plain data classes: User, Order
  Repository.ts        # Generic Repository<T> (not decorated)
  AppModule.ts         # @Module with @Provides for repositories + appName
  UserService.ts       # @Singleton, injects Repository<User>
  OrderService.ts      # @Singleton, injects Repository<Order>
  main.ts              # Bootstraps context and exercises the beans
  AppContext.generated.ts  # Generated by the transformer
```

## Usage

### Generate the context file

```bash
pnpm generate
```

This runs the `@goodie-ts/transformer` against `tsconfig.json` and produces `src/AppContext.generated.ts`.

### Build with Vite

```bash
pnpm build
```

Uses `@goodie-ts/vite-plugin` to run the transform automatically during `vite build`.

## Generated output

The transformer produces 6 bean definitions:

| Bean | Token | Source |
|---|---|---|
| `AppModule` | `AppModule` (class) | `@Module()` decorator |
| `Repository<User>` | `InjectionToken('Repository<User>')` | `AppModule.userRepository()` |
| `Repository<Order>` | `InjectionToken('Repository<Order>')` | `AppModule.orderRepository()` |
| `UserService` | `UserService` (class) | `@Singleton()` decorator |
| `OrderService` | `OrderService` (class) | `@Singleton()` decorator |
| `appName` | `InjectionToken('appName')` | `AppModule.appName()` |
