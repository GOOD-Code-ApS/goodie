import path from 'node:path';
import type {
  IRBeanDefinition,
  IRControllerDefinition,
  TokenRef,
} from './ir.js';

/** Info about an auto-generated InjectionToken. */
interface TokenInfo {
  tokenName: string;
  typeAnnotation: string | undefined;
}

/** Options for code generation. */
export interface CodegenOptions {
  /** Absolute path of the output file (used for computing relative imports). */
  outputPath: string;
  /** Transformer version string (e.g. '0.1.0'). Embedded in the header comment. */
  version?: string;
}

/**
 * Generate the AppContext.generated.ts source from topologically sorted beans.
 */
export function generateCode(
  beans: IRBeanDefinition[],
  options: CodegenOptions,
  controllers?: IRControllerDefinition[],
): string {
  const outputDir = path.dirname(options.outputPath);
  const lines: string[] = [];

  // Check if any bean uses @Value
  const hasValueFields = beans.some(
    (b) =>
      b.metadata.valueFields &&
      (b.metadata.valueFields as unknown[]).length > 0,
  );

  // Header
  const versionTag = options.version ? ` v${options.version}` : '';
  const timestamp = new Date().toISOString();
  lines.push(
    `// AppContext.generated.ts — DO NOT EDIT (generated by @goodie-ts/transformer${versionTag} at ${timestamp})`,
  );
  lines.push("import { ApplicationContext, Goodie } from '@goodie-ts/core'");
  lines.push(
    "import type { BeanDefinition, Dependency } from '@goodie-ts/core'",
  );

  // Collect unique class imports and injection tokens
  const classImports = collectClassImports(beans);
  const injectionTokens = collectInjectionTokens(beans);

  // If @Value is used, add the config token
  const needsInjectionToken = injectionTokens.length > 0 || hasValueFields;
  if (needsInjectionToken) {
    lines.push("import { InjectionToken } from '@goodie-ts/core'");
  }

  // Build collision-safe tokenName → varName mapping
  const tokenVarNameMap = buildTokenVarNameMap(injectionTokens);
  const resolveTokenRef = (ref: TokenRef): string => {
    if (ref.kind === 'class') return ref.className;
    return tokenVarNameMap.get(ref.tokenName) ?? tokenVarName(ref.tokenName);
  };

  // Class imports
  for (const [className, importPath] of classImports) {
    const relativePath = computeRelativeImport(outputDir, importPath);
    lines.push(`import { ${className} } from '${relativePath}'`);
  }

  // Type-only imports for types referenced in token generics
  const typeOnlyImports = collectTypeOnlyImports(
    beans,
    classImports,
    outputDir,
  );
  for (const [typeName, importSpec] of typeOnlyImports) {
    lines.push(`import type { ${typeName} } from '${importSpec}'`);
  }

  lines.push('');

  // Config token (if @Value is used)
  // Reserved name — graph-builder validates no user bean collides with '__Goodie_Config'
  if (hasValueFields) {
    lines.push(
      "export const __Goodie_Config = new InjectionToken<Record<string, unknown>>('__Goodie_Config')",
    );
    lines.push('');
  }

  // InjectionToken declarations (exported + typed)
  for (const token of injectionTokens) {
    const varName = tokenVarNameMap.get(token.tokenName)!;
    const typeParam = token.typeAnnotation ?? 'unknown';
    lines.push(
      `export const ${varName} = new InjectionToken<${typeParam}>('${token.tokenName}')`,
    );
  }

  if (injectionTokens.length > 0) {
    lines.push('');
  }

  // Bean definitions array
  if (hasValueFields) {
    lines.push(
      'export function buildDefinitions(config?: Record<string, unknown>): BeanDefinition[] {',
    );
    lines.push('  return [');
    // Config bean definition
    lines.push('    {');
    lines.push('      token: __Goodie_Config,');
    lines.push("      scope: 'singleton',");
    lines.push('      dependencies: [],');
    lines.push(
      '      factory: () => ({ ...process.env, ...config } as Record<string, unknown>),',
    );
    lines.push('      eager: false,');
    lines.push('      metadata: {},');
    lines.push('    },');
  } else {
    lines.push('const definitions: BeanDefinition[] = [');
  }

  for (const bean of beans) {
    lines.push('  {');
    lines.push(`    token: ${resolveTokenRef(bean.tokenRef)},`);
    lines.push(`    scope: '${bean.scope}',`);
    lines.push(
      `    dependencies: ${depsToCode(bean, resolveTokenRef, hasValueFields)},`,
    );
    lines.push(`    factory: ${factoryToCode(bean)},`);
    lines.push(`    eager: ${bean.eager},`);
    lines.push(`    metadata: ${metadataToCode(bean.metadata)},`);
    lines.push('  },');
  }

  if (hasValueFields) {
    lines.push('  ]');
    lines.push('}');
    lines.push('');
    lines.push('const definitions = buildDefinitions()');
  } else {
    lines.push(']');
  }
  lines.push('');

  // createContext function
  if (hasValueFields) {
    lines.push(
      'export async function createContext(config?: Record<string, unknown>): Promise<ApplicationContext> {',
    );
    lines.push('  return ApplicationContext.create(buildDefinitions(config))');
    lines.push('}');
  } else {
    lines.push(
      'export async function createContext(): Promise<ApplicationContext> {',
    );
    lines.push('  return ApplicationContext.create(definitions)');
    lines.push('}');
  }
  lines.push('');
  lines.push('export { definitions }');
  lines.push('');

  if (hasValueFields) {
    lines.push('export function createApp(config?: Record<string, unknown>) {');
    lines.push('  return Goodie.build(buildDefinitions(config))');
    lines.push('}');
    lines.push('');
    lines.push('export const app = createApp()');
  } else {
    lines.push('export const app = Goodie.build(definitions)');
  }
  lines.push('');

  // Generate createRouter() if controllers with routes exist
  const activeControllers = (controllers ?? []).filter(
    (c) => c.routes.length > 0,
  );
  if (activeControllers.length > 0) {
    lines.push(
      ...generateCreateRouter(activeControllers, classImports, outputDir),
    );
  }

  return lines.join('\n');
}

/** Collect unique class imports: Map<className, absoluteImportPath> */
function collectClassImports(beans: IRBeanDefinition[]): Map<string, string> {
  const imports = new Map<string, string>();

  for (const bean of beans) {
    addClassImport(imports, bean.tokenRef);

    for (const dep of bean.constructorDeps) {
      addClassImport(imports, dep.tokenRef);
    }

    for (const field of bean.fieldDeps) {
      addClassImport(imports, field.tokenRef);
    }

    if (bean.providesSource) {
      addClassImport(imports, bean.providesSource.moduleTokenRef);
    }
  }

  return imports;
}

function addClassImport(imports: Map<string, string>, ref: TokenRef): void {
  if (ref.kind === 'class') {
    imports.set(ref.className, ref.importPath);
  }
}

/** Collect unique auto-generated InjectionTokens with their type info. */
function collectInjectionTokens(beans: IRBeanDefinition[]): TokenInfo[] {
  const seen = new Map<string, TokenInfo>();

  function add(ref: TokenRef): void {
    if (ref.kind !== 'injection-token') return;
    if (seen.has(ref.tokenName)) return;
    seen.set(ref.tokenName, {
      tokenName: ref.tokenName,
      typeAnnotation: ref.typeAnnotation,
    });
  }

  for (const bean of beans) {
    add(bean.tokenRef);
    for (const dep of bean.constructorDeps) add(dep.tokenRef);
    for (const field of bean.fieldDeps) add(field.tokenRef);
  }

  return [...seen.values()];
}

/**
 * Collect type-only imports needed for token generic type annotations.
 * Uses the typeImports map from InjectionTokenRefs to find the correct
 * source file for each type.
 */
function collectTypeOnlyImports(
  beans: IRBeanDefinition[],
  classImports: Map<string, string>,
  outputDir: string,
): Map<string, string> {
  const typeImports = new Map<string, string>();

  // Collect all InjectionTokenRefs that have type imports
  for (const bean of beans) {
    addTypeImports(bean.tokenRef);
    for (const dep of bean.constructorDeps) addTypeImports(dep.tokenRef);
    for (const field of bean.fieldDeps) addTypeImports(field.tokenRef);
  }

  function addTypeImports(ref: TokenRef): void {
    if (ref.kind !== 'injection-token') return;
    if (!ref.typeImports) return;

    for (const [typeName, absolutePath] of ref.typeImports) {
      if (classImports.has(typeName)) continue;
      if (typeImports.has(typeName)) continue;
      const relativePath = computeRelativeImport(outputDir, absolutePath);
      typeImports.set(typeName, relativePath);
    }
  }

  return typeImports;
}

/**
 * Build a Map<tokenName, uniqueVarName> with collision detection.
 * When two different tokenNames produce the same varName, append _2, _3, etc.
 */
function buildTokenVarNameMap(tokens: TokenInfo[]): Map<string, string> {
  const result = new Map<string, string>();
  // Track varName → how many times it's been assigned (for suffix generation)
  const varNameCounts = new Map<string, number>();

  for (const token of tokens) {
    const baseVarName = tokenVarName(token.tokenName);
    const count = varNameCounts.get(baseVarName) ?? 0;

    if (count === 0) {
      result.set(token.tokenName, baseVarName);
    } else {
      result.set(token.tokenName, `${baseVarName}_${count + 1}`);
    }
    varNameCounts.set(baseVarName, count + 1);
  }

  return result;
}

/**
 * Generate the exported variable name for a token in Pascal_Snake_Case.
 * E.g. 'Repository<User>' → 'Repository_User_Token'
 *      'appName'           → 'App_Name_Token'
 *      'dbUrl'             → 'Db_Url_Token'
 *      'port'              → 'Port_Token'
 */
function tokenVarName(tokenName: string): string {
  // 1. Replace generic chars with underscores
  const sanitized = tokenName.replace(/[<>, ]/g, '_');

  // 2. Split on underscores, filter empty segments
  const segments = sanitized.split('_').filter(Boolean);

  // 3. Split camelCase within each segment, capitalize each word
  const words = segments.flatMap((seg) =>
    seg
      .replace(/([a-z])([A-Z])/g, '$1_$2')
      .split('_')
      .map((w) => w.charAt(0).toUpperCase() + w.slice(1)),
  );

  return [...words, 'Token'].join('_');
}

/** Convert all dependencies of a bean (constructor + field) to code. */
function depsToCode(
  bean: IRBeanDefinition,
  resolveTokenRef: (ref: TokenRef) => string,
  hasValueFields = false,
): string {
  const allDeps = [
    ...bean.constructorDeps.map((d) => ({
      token: resolveTokenRef(d.tokenRef),
      optional: d.optional,
      collection: d.collection,
    })),
    ...bean.fieldDeps.map((f) => ({
      token: resolveTokenRef(f.tokenRef),
      optional: f.optional,
      collection: false,
    })),
  ];

  // If this bean has @Value fields, add config token as last dependency
  const beanValueFields = bean.metadata.valueFields as
    | Array<{ fieldName: string; key: string; default?: string }>
    | undefined;
  if (hasValueFields && beanValueFields && beanValueFields.length > 0) {
    allDeps.push({
      token: '__Goodie_Config',
      optional: false,
      collection: false,
    });
  }

  if (allDeps.length === 0) return '[]';

  const items = allDeps.map((d) => {
    const parts = [
      `token: ${d.token}`,
      `optional: ${d.optional}`,
      `collection: ${d.collection}`,
    ];
    return `{ ${parts.join(', ')} }`;
  });
  return `[${items.join(', ')}]`;
}

/** Generate the factory function code for a bean. */
function factoryToCode(bean: IRBeanDefinition): string {
  if (bean.factoryKind === 'provides') {
    return providesFactoryToCode(bean);
  }

  return constructorFactoryToCode(bean);
}

function constructorFactoryToCode(bean: IRBeanDefinition): string {
  const className =
    bean.tokenRef.kind === 'class'
      ? bean.tokenRef.className
      : bean.tokenRef.tokenName;

  const beanValueFields = bean.metadata.valueFields as
    | Array<{ fieldName: string; key: string; default?: string }>
    | undefined;
  const hasValues = beanValueFields && beanValueFields.length > 0;

  const ctorParams = bean.constructorDeps.map((_, i) => `dep${i}`);
  const allParams = [...ctorParams];
  const fieldParams = bean.fieldDeps.map((_, i) => `field${i}`);
  allParams.push(...fieldParams);
  if (hasValues) {
    allParams.push('__config');
  }

  if (allParams.length === 0 && bean.fieldDeps.length === 0 && !hasValues) {
    return `() => new ${className}()`;
  }

  const paramList = allParams.map((p) => `${p}: any`).join(', ');
  const ctorArgs = ctorParams.join(', ');

  if (bean.fieldDeps.length === 0 && !hasValues) {
    return `(${paramList}) => new ${className}(${ctorArgs})`;
  }

  // Constructor + field injection + value injection
  const fieldAssignments = bean.fieldDeps
    .map((f, i) => `    instance.${f.fieldName} = field${i}`)
    .join('\n');

  const valueAssignments = hasValues
    ? beanValueFields
        .map((vf) => {
          const safeKey = escapeStringLiteral(vf.key);
          if (vf.default !== undefined) {
            return `    instance.${vf.fieldName} = __config['${safeKey}'] ?? ${vf.default}`;
          }
          return `    instance.${vf.fieldName} = __config['${safeKey}']`;
        })
        .join('\n')
    : '';

  const assignments = [fieldAssignments, valueAssignments]
    .filter(Boolean)
    .join('\n');

  return `(${paramList}) => {
    const instance = new ${className}(${ctorArgs})
${assignments}
    return instance
  }`;
}

function providesFactoryToCode(bean: IRBeanDefinition): string {
  if (!bean.providesSource)
    return '() => { throw new Error("missing provides source") }';

  const { moduleTokenRef, methodName } = bean.providesSource;

  // First dep is always the module instance
  const params = bean.constructorDeps.map((_, i) => `dep${i}: any`);
  const args = bean.constructorDeps.slice(1).map((_, i) => `dep${i + 1}`);

  const paramList = params.join(', ');
  const argList = args.join(', ');

  return `(${paramList}) => (dep0 as ${moduleTokenRef.className}).${methodName}(${argList})`;
}

function metadataToCode(metadata: Record<string, unknown>): string {
  const entries = Object.entries(metadata);
  if (entries.length === 0) return '{}';

  const items = entries.map(([k, v]) => `${k}: ${JSON.stringify(v)}`);
  return `{ ${items.join(', ')} }`;
}

/** Compute a relative import path from the output dir to the target file, with .js extension. */
function computeRelativeImport(
  outputDir: string,
  absolutePath: string,
): string {
  // Handle node_modules paths → extract bare package specifier
  if (absolutePath.includes('node_modules')) {
    return extractPackageName(absolutePath);
  }

  let relative = path.relative(outputDir, absolutePath);

  // Replace .ts extension with .js
  relative = relative.replace(/\.tsx?$/, '.js');

  // Ensure it starts with ./
  if (!relative.startsWith('.')) {
    relative = `./${relative}`;
  }

  return relative;
}

/**
 * Extract a bare package name from a node_modules path.
 * E.g. '/project/node_modules/pg/lib/index.d.ts' → 'pg'
 *      '/project/node_modules/@types/pg/index.d.ts' → 'pg'
 *      '/project/node_modules/@scope/pkg/lib/index.d.ts' → '@scope/pkg'
 */
function extractPackageName(absolutePath: string): string {
  const segments = absolutePath.split('/node_modules/');
  const afterNodeModules = segments[segments.length - 1];
  const parts = afterNodeModules.split('/');

  let packageName: string;
  if (parts[0].startsWith('@')) {
    // Scoped package: @scope/name
    packageName = `${parts[0]}/${parts[1]}`;
  } else {
    packageName = parts[0];
  }

  // Strip @types/ prefix (e.g. @types/pg → pg)
  if (packageName.startsWith('@types/')) {
    packageName = packageName.slice('@types/'.length);
  }

  return packageName;
}

/**
 * Escape characters that could break out of a single-quoted string literal.
 * Prevents code injection via @Value keys.
 */
function escapeStringLiteral(value: string): string {
  return value
    .replace(/\\/g, '\\\\')
    .replace(/'/g, "\\'")
    .replace(/\n/g, '\\n')
    .replace(/\r/g, '\\r');
}

// ── createRouter generation ──

/**
 * Generate a createRouter() function that registers all controller routes on a Hono app.
 * The generated function takes an ApplicationContext and returns a Hono instance.
 */
function generateCreateRouter(
  controllers: IRControllerDefinition[],
  classImports: Map<string, string>,
  outputDir: string,
): string[] {
  const lines: string[] = [];

  // Add Hono import
  lines.push("import { Hono } from 'hono'");

  // Add controller imports for any controllers not already imported via beans
  // Track by importPath to handle same-named classes from different files
  const importedPaths = new Set<string>(classImports.values());
  for (const ctrl of controllers) {
    if (!importedPaths.has(ctrl.classTokenRef.importPath)) {
      const relativePath = computeRelativeImport(
        outputDir,
        ctrl.classTokenRef.importPath,
      );
      lines.push(
        `import { ${ctrl.classTokenRef.className} } from '${relativePath}'`,
      );
      importedPaths.add(ctrl.classTokenRef.importPath);
    }
  }

  lines.push('');
  lines.push('export function createRouter(ctx: ApplicationContext): Hono {');
  lines.push('  const app = new Hono()');

  // Build collision-safe variable names for controllers
  const ctrlVarNames = buildControllerVarNames(controllers);

  for (const ctrl of controllers) {
    const varName = ctrlVarNames.get(controllerKey(ctrl))!;
    lines.push(`  const ${varName} = ctx.get(${ctrl.classTokenRef.className})`);

    for (const route of ctrl.routes) {
      const fullPath = joinPaths(ctrl.basePath, route.path);
      lines.push(`  app.${route.httpMethod}('${fullPath}', async (c) => {`);
      lines.push(`    const result = await ${varName}.${route.methodName}(c)`);
      lines.push('    if (result instanceof Response) return result');
      lines.push(
        '    if (result === undefined || result === null) return c.body(null, 204)',
      );
      lines.push('    return c.json(result)');
      lines.push('  })');
    }
  }

  lines.push('  return app');
  lines.push('}');
  lines.push('');

  return lines;
}

/**
 * Build a Map<"className:importPath", uniqueVarName> with collision detection.
 * When two controllers produce the same camelCase name, append _2, _3, etc.
 * Uses composite key to handle same-named controllers from different files.
 */
function buildControllerVarNames(
  controllers: IRControllerDefinition[],
): Map<string, string> {
  const result = new Map<string, string>();
  const varNameCounts = new Map<string, number>();

  for (const ctrl of controllers) {
    const key = controllerKey(ctrl);
    const className = ctrl.classTokenRef.className;
    const baseVarName = className.charAt(0).toLowerCase() + className.slice(1);
    const count = varNameCounts.get(baseVarName) ?? 0;

    if (count === 0) {
      result.set(key, baseVarName);
    } else {
      result.set(key, `${baseVarName}_${count + 1}`);
    }
    varNameCounts.set(baseVarName, count + 1);
  }

  return result;
}

/** Stable key for a controller to avoid same-name collisions across files. */
function controllerKey(ctrl: IRControllerDefinition): string {
  return `${ctrl.classTokenRef.className}:${ctrl.classTokenRef.importPath}`;
}

/** Join a base path and a route path, normalizing slashes. */
function joinPaths(basePath: string, routePath: string): string {
  // Normalize: remove trailing slash from base, ensure leading slash on route
  const base = basePath.endsWith('/') ? basePath.slice(0, -1) : basePath;
  const route = routePath.startsWith('/') ? routePath : `/${routePath}`;

  // Special case: if route is just '/', return the base
  if (route === '/') return base || '/';

  return `${base}${route}`;
}
